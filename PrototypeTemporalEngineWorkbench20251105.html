<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-900 text-gray-200">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temporal Engine Workbench made by Google Gemini, mangled by moi</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Simple styling for the log */
        #log {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.8rem;
            line-height: 1.2;
            color: #16a34a; /* Green text */
            background-color: #020617; /* Black */
            border-color: #374151; /* Gray border */
        }
    </style>
</head>
<body class="h-full font-sans p-6 md:p-10">
    <div class="flex flex-col h-full max-w-7xl mx-auto">
        <header class="pb-4 border-b border-gray-700">
            <h1 class="text-3xl font-bold tracking-tight text-white">Temporal Engine Workbench</h1>
            <p class="mt-1 text-lg text-gray-400">The <span class="font-medium text-yellow-300">Temporal "Single-Array" Engine</span>. (v3)</p>
        </header>

        <main class="flex flex-col md:flex-row flex-1 gap-6 mt-6 min-h-0">
            <!-- Left Column: Controls & Log -->
            <div class="flex flex-col md:w-1/3 space-y-4">
                <h2 class="text-xl font-semibold text-white">Controls</h2>
                <div class="grid grid-cols-2 gap-3">
                    <button id="startBtn" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all">Start Simulation</button>
                    <button id="stopBtn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all">Stop</button>
                </div>
                <div class="flex-1 flex flex-col min-h-0">
                    <h2 class="text-xl font-semibold text-white mb-2">Simulation Log</h2>
                    <textarea id="log" readonly class="w-full flex-1 rounded-lg border-2 p-3"></textarea>
                </div>
            </div>

            <!-- Right Column: Visualization -->
            <div class="flex flex-col md:w-2/3 min-h-0">
                <div class_id="canvas-container" class="border-2 border-gray-700 rounded-lg bg-gray-800 p-4 h-full">
                    <div>
                        <h2 class="text-xl font-semibold text-white">Engine (v3)</h2>
                        <p class="text-sm text-gray-400">This engine doesn't use your "single-array" and "sliding-index" model. It calls `Date.now()` and compensates for lag by modifying the 5D `wait_duration`.</p>
                        <canvas id="simulationCanvas" class="w-full h-96 bg-black rounded-md mt-4"></canvas>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script type="module">
        // --- Shared Components ---
        const logEl = document.getElementById('log');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const simCtx = document.getElementById('simulationCanvas').getContext('2d');

        let animationFrameId = null;
        let originTime = 0; // The 'origin_T'
        
        // This is our 'time()' wrapper
        function getPresentTime() {
            if (originTime === 0) return 0; // Not started
            return Date.now() - originTime;
        }
        
       function logMessage(msg) {
            const time = (getPresentTime() / 1000.0).toFixed(3);
            logEl.value += `[t=${time}s] ${msg}<br>`;
            logEl.scrollTop = logEl.scrollHeight;
        }

   
       function     draw(line, progress) {
		   
                simCtx.fillStyle = '#22c55e'; // Green
                simCtx.globalAlpha = 0.8;
                const y = (line.id * 10) + 10;
                const p = (progress);
                simCtx.fillRect(p * simCtx.canvas.width - 2, y, 4, 8);
            }
 

/**
 * Step 1: Temporal_Thing
 *
 * This class represents a single object with a 4D "duration" (its active
 * life) and a 5D "delay" (its latent, "insurance" period).
 *
 * Your Cartesian Plane Analogy:
 * - An object is EITHER in "delay" (on the y-axis).
 * - OR it is in "duration" (on the x-axis).
 * - They are sequential: the 'end_of_delay' IS the 'start_of_duration'.
 */
class Temporal_Thing {
    constructor(duration, delay, idd=2) {
		this.id = idd;
        // --- 4D/5D Axioms (The "pure" virtual values) ---
        this.duration = duration || 0; // 4D Element
        this.delay = delay || 0;     // 5D Element (the "insurance")

        // --- "Real World" Projected State ---
 
        // The "Delay" Phase (Y-Axis)
        this.start_of_delay = 0;
        this.end_of_delay = 0;

        // The "Duration" Phase (X-Axis)
        this.start_of_duration = 0;
        this.end_of_duration = 0;
        
        // These are the "reality" variables you added,
        // which get updated when progress is checked.
        this.delay_remaining = 0; 
        this.duration_remaining = 0;
    }

    /**
     * Schedules the *entire* next cycle (delay + duration).
     * This is the "reaction" function.
     * @param {number} cycle_start_time - The "real-world" time (from Date.now())
     * that the *delay* phase begins.
     * @param {number} compensated_delay - The "real-world" compensated delay
     * (axiom_delay - lag_error).
     */
    schedule_next_cycle(cycle_start_time, compensated_delay) {
        // 1. Set the "Delay" Phase (Y-Axis)
        this.start_of_delay = cycle_start_time;
        // Ensure delay is not negative, but allow 0
        const effective_delay = Math.max(0, compensated_delay);
        this.end_of_delay = this.start_of_delay + effective_delay;

        // 2. Set the "Duration" Phase (X-Axis)
        // This is the CRITICAL LINK: The "duration" starts when the "delay" ends.
        this.start_of_duration = this.end_of_delay;
 
        this.end_of_duration = this.start_of_duration + this.duration; 
    }

    /**
     * Renamed from 'get_remainingDelay'.
     * Returns the *progress* (0.0 to 1.0) through the *delay* phase.
     * Returns 0 if not currently in the delay phase.
     */
    get_progressDelay(present) {
        // We use 'end_of_delay' to get the compensated duration
        const compensated_delay = this.end_of_delay - this.start_of_delay;
        if (present < this.start_of_delay || present >= this.end_of_delay || compensated_delay <= 0) {
            this.delay_remaining = 0; // Not in delay, so 0 remaining
            return 0; 
        }
        // This is your "reality" variable update.
 
        this.delay_remaining = present - this.start_of_delay; 
        const progress = this.delay_remaining / compensated_delay;
        return Math.min(1.0, Math.max(0.0, progress));
    }

    /**
     * Renamed from 'get_remainingDuration'.
     * Returns the *progress* (0.0 to 1.0) through the *duration* (active) phase.
     * Returns 0 if not currently in the duration phase.
     */
    get_progressDuration(present) {
        if (present < this.start_of_duration || present >= this.end_of_duration || this.duration <= 0) {
            this.duration_remaining = 0; // Not active, so 0 remaining
            return 0;
        }
        // This is your "reality" variable update.
        this.duration_remaining = present - this.start_of_duration; 
			
        const progress = this.duration_remaining / this.duration;
        return Math.min(1.0, Math.max(0.0, progress));
    }
    
    /**
     * A simple check to see if the object is in its "duration" (active) phase.
     * This is what the LERP function will check.
     */
    isActive(present) {
        return (present >= this.start_of_duration && present < this.end_of_duration);
    }

    /**
     * A simple check to see if the object's "duration" has finished.
     * This is what the "reaction" function will check.
     */
    isFinished(present) {
        return (present >= this.end_of_duration);
    }
}

// --- Step 2: The "Two-Array" Manager ---
// This class implements your "latent" and "active" array concept.
class Temporal_Array {
    constructor() {
        // The "Latent" list, sorted by 'start_of_duration' (ascending)
        this.latent = [];
        
        // The "Active" list, sorted by 'end_of_duration' (ascending)
        // This is "objectively fair"
        this.active = [];
    }

    /**
     * Inserts a "thing" into the LATENT array,
     * sorted by 'start_of_duration'.
     */
    insertLatent(thing) {
        // --- O(log N) Binary Search ---
        let low = 0;
        let high = this.latent.length;

        while (low < high) {
            const mid = Math.floor((low + high) / 2);
            if (this.latent[mid].start_of_duration < thing.start_of_duration) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        const index = low;
        // --- End Binary Search ---

        if (index === this.latent.length) {
            this.latent.push(thing);
        } else {
            this.latent.splice(index, 0, thing);
        }
    }
    
    /**
     * Inserts a "thing" into the ACTIVE array,
     * sorted by 'end_of_duration'.
     */
    insertActive(thing) {
        // --- O(log N) Binary Search ---
        let low = 0;
        let high = this.active.length;

        while (low < high) {
            const mid = Math.floor((low + high) / 2);
            if (this.active[mid].end_of_duration < thing.end_of_duration) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        const index = low;
        // --- End Binary Search ---
        
        if (index === this.active.length) {
            this.active.push(thing);
        } else {
            this.active.splice(index, 0, thing);
        }
    }

    /**
     * This is the "Calculator" for mega-lag.
     * It "catches up" a thing's state by fast-forwarding
     * it to the 'present_time'.
     */
    fast_forward_thing(thing, present_time) {
        const cycle_time = thing.duration + thing.delay;
        if (cycle_time <= 0) return; // Avoid division by zero
        
        // Calculate how many *full cycles* were missed
        const time_since_start = present_time - thing.start_of_delay;
        const multiple = Math.floor(time_since_start / cycle_time);
   logMessage(`inside fast forward : time_since_start = ${time_since_start}`);
        if (multiple > 0) {
            // It has missed at least one cycle.
            // We "teleport" its virtual start time forward.
            const new_start_of_delay = thing.start_of_delay + (multiple * cycle_time);
            
            // Re-schedule it based on this new *virtual* time
            // We use the "axiom" delay, as the "lag" is so big
            // the compensation is irrelevant.
            thing.schedule_next_cycle(new_start_of_delay, thing.delay);
	logMessage(`given multiples inside fastforward ${new_start_of_delay}`);		
        }
    }

    /**
     * This is the "Reaction" function.
     * It's called by the 'tick' loop when a 'thing' is finished.
     * It performs the "Temporal" lag compensation.
     */
    particle_Hit(thing, present_time) {
        // 1. Calculate the "error" (lag).
        // This is the "real" time minus the "allotted" time.
        const error = present_time - thing.end_of_duration;

        // 2. Calculate the "compensated" delay.
        // This is the "insurance" (axiom) minus the "error" (lag).
        const compensated_delay = thing.delay - error;
        
        // 3. Schedule the *next* full cycle.
        // The next cycle's *delay* starts at the *allotted end time*.
        const next_cycle_start_time = thing.end_of_duration;
        thing.schedule_next_cycle(next_cycle_start_time, compensated_delay);

        // 4. Re-insert the thing into the "latent" array.
        this.insertLatent(thing);
    }
    
  /**
     * This is the master "tick" for our merged engine.
     * It now handles 'delta_time' to detect mega-lag.
     *
     * @param {number} present_time - The "real" time (from Date.now())
     * @param {number} delta_time - The time *since the last tick*
     * @param {function} render_Callback - The function to call to LERP/draw.
     */
    tick(present_time, delta_time, render_Callback) {
        
                simCtx.clearRect(0, 0, simCtx.canvas.width, simCtx.canvas.height);
        // --- Phase 1: Activation ---
        // Move "ready" things from 'latent' to 'active'
        // This is the "catch-up" loop for activations.
        while (this.latent.length > 0 && 
               this.latent[0].start_of_duration <= present_time) {
            
            const thing_to_activate = this.latent.shift();
            
            // --- MEGA-LAG CHECK (Activation) ---
            // This is the "Calculator" logic you wanted.
            // If the *entire* duration has passed since the last
            // tick, we must "fast-forward" it.
            const cycle_time = thing_to_activate.duration + thing_to_activate.delay;
            if (delta_time >= cycle_time) {
                // This thing might have cycled *multiple times*
                // while it was "latent".
                this.fast_forward_thing(thing_to_activate, present_time);
            }
            
            // Now, we check its *new* (fast-forwarded) state.
            if (thing_to_activate.start_of_duration <= present_time) {
                // It's still ready to be active
                this.insertActive(thing_to_activate);
            } else {
                // The "fast-forward" pushed it *back* into the
                // future. Re-insert it as "latent".
                this.insertLatent(thing_to_activate);
            }
        }

        // --- Phase 2: Reaction & Rendering ---
        // This loop is "objectively fair"
        for (let i = this.active.length - 1; i >= 0;  i--) {
            const thing = this.active[i];

            // --- MEGA-LAG CHECK (Reaction) ---
            // This is the "Calculator" logic for the active list.
            const cycle_time = thing.duration + thing.delay;
            if (delta_time >= cycle_time) {
                // The browser froze for a whole cycle.
                // We must "fast-forward" this thing.
                this.active.splice(i, 1);
                this.fast_forward_thing(thing, present_time);

                // Now, check its *new* (fast-forwarded) state.
                if (thing.start_of_duration <= present_time) {
                    this.insertActive(thing);
                } else {
                    this.insertLatent(thing);
                }
                 
                continue;
            }
            
            // --- NORMAL FINISH (Reaction) ---
            // This is the "semantically-obtuse" check,
            // but it's now "safe" because we've handled
            // the mega-lag case first.
            if (thing.end_of_duration <= present_time) {
                this.active.splice(i, 1);
                this.particle_Hit(thing, present_time);
                i--;
                continue; 
            }

            // --- NORMAL RENDER ---
            // If it wasn't mega-lagged and wasn't finished,
            // it must be "active" and ready to render.
            // (We could add the isActive check for safety)
            const progress = thing.get_progressDuration(present_time);
            render_Callback(thing, progress);
        }
    }
}

// --- Step 3: The Engine "Interface" ---
// This is the final, thin wrapper that connects our
// Temporal_Array to the "real world" (e.g., requestAnimationFrame).
class Temporal_Engine {
    constructor(render_Callback) {
        this.temporal_array = new Temporal_Array();
        this.origin_T = 0; // The 'Date.now()' when the simulation started
        this.animationFrameId = null;
               // to detect the "delta_time".
        this.last_present_time = 0; 
        // The LERP/draw function
        this.render_Callback = render_Callback; 
        
        // Bind the 'tick' method so 'this' is correct
        // when requestAnimationFrame calls it.
        this.tick = this.tick.bind(this);
    }

    /**
     * This is our time() wrapper.
     * It gets the "real" time, aligned to our origin.
     */
    getPresentTime() {
        if (this.origin_T === 0) return 0;
        return Date.now() - this.origin_T;
    }
    
    /**
     * Add a 'thing' to the engine.
     * We must "schedule" its first cycle.
     */
    addThing(thing, initial_start_time) {
        // We use the "axiom" delay for the first cycle
        const compensated_delay = thing.delay; 
        thing.schedule_next_cycle(initial_start_time, compensated_delay);
        this.temporal_array.insertLatent(thing);
    }
	
   /**
     * This is the "master" loop that runs every frame.
     * It is now "mega-lag" aware.
     */
    tick() {
        // 1. Get the "real" time snapshot.
        const present_time = this.getPresentTime();
        
        // 2. Calculate the "delta_time" (the "mega-lag").
        const delta_time = present_time - this.last_present_time;
        
        // 3. Pass *both* "real" time and "delta" time
        //    to the "Calculator".
        this.temporal_array.tick(present_time, delta_time, this.render_Callback);
        
        // 4. Remember this frame's time for the next tick.
        this.last_present_time = present_time;
        
        // 5. Keep the loop going.
        this.animationFrameId = requestAnimationFrame(this.tick);
    }
    
    start() {
        if (this.animationFrameId) return; // Already running
if(this.origin_T == 0){        this.origin_T = Date.now();}
        this.last_present_time = this.getPresentTime();
		
            logMessage(`Start at ${this.last_present_time}`);


if(this.temporal_array.active.length) logMessage(`2 lines are Active: [start_of_duration: ${this.temporal_array.active[0].start_of_duration} end_of_duration:${this.temporal_array.active[0].end_of_duration} Start_of_delay:${this.temporal_array.active[0].start_of_delay} End_of_delay:${this.temporal_array.active[0].end_of_delay}] \n`);

if(this.temporal_array.latent.length) logMessage(`		Latent [start_of_duration: ${this.temporal_array.latent[0].start_of_duration} end_of_duration:${this.temporal_array.latent[0].end_of_duration} start_of_delay:${this.temporal_array.latent[0].start_of_delay}  end_of_delay:${this.temporal_array.latent[0].end_of_delay}] \n  `);
        this.animationFrameId = requestAnimationFrame(this.tick);
    }
    
    stop() {
        if (!this.animationFrameId) return; // Already stopped
		logMessage(`Stopped at ${this.last_present_time}`);


if(this.temporal_array.active.length) logMessage(`2 lines are Active: [start_of_duration: ${this.temporal_array.active[0].start_of_duration} end_of_duration:${this.temporal_array.active[0].end_of_duration} Start_of_delay:${this.temporal_array.active[0].start_of_delay} End_of_delay:${this.temporal_array.active[0].end_of_delay}] \n`);

if(this.temporal_array.latent.length) logMessage(`		Latent [start_of_duration: ${this.temporal_array.latent[0].start_of_duration} end_of_duration:${this.temporal_array.latent[0].end_of_duration} start_of_delay:${this.temporal_array.latent[0].start_of_delay}  end_of_delay:${this.temporal_array.latent[0].end_of_delay}] \n  `);

        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
    }
}

        // --- Main Setup & Loop ---
        const simulationEngine = new Temporal_Engine(draw);
startBtn.addEventListener('click', () => {simulationEngine.start();});
stopBtn.addEventListener('click', () => {simulationEngine.stop();});
        function setup() {
            logMessage("Temporal Engine (v3) initialized.");
            const lines = [
                new Temporal_Thing(1000, 2000,2 ),  
               // new Temporal_Thing(1500, 1000,3 ),
               // new Temporal_Thing(3000, 500,7 ),
               // new Temporal_Thing(500, 4000,11 ) 
            ];
            console.log(`first item in lines is ${typeof lines[0]} and it is ${JSON.stringify(lines[0])}`);
            lines.forEach(thng => { simulationEngine.addThing(thng, thng.start_of_duration);}); 
            
            simCtx.canvas.width = simCtx.canvas.clientWidth;
            simCtx.canvas.height = simCtx.canvas.clientHeight;
        }
 
 
        // Initialize
        setup();

    </script> 
<br>	</body>
<br>	</html>
